{"ast":null,"code":"var util = require('util');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nmodule.exports = Iterator;\n\nfunction Iterator(db, options) {\n  if (!options) options = {};\n  this.options = options;\n  AbstractIterator.call(this, db);\n  this._order = options.reverse ? 'DESC' : 'ASC';\n  this._limit = options.limit;\n  this._count = 0;\n  this._done = false;\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n\n  try {\n    this._keyRange = lower || upper ? this.db.makeKeyRange({\n      lower: lower,\n      upper: upper,\n      excludeLower: ltgt.lowerBoundExclusive(options),\n      excludeUpper: ltgt.upperBoundExclusive(options)\n    }) : null;\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._keyRangeError = true;\n  }\n\n  this.callback = null;\n}\n\nutil.inherits(Iterator, AbstractIterator);\n\nIterator.prototype.createIterator = function () {\n  var self = this;\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments);\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function (err) {\n      console.log('horrible error', err);\n    }\n  });\n}; // TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\n\n\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback();\n    this.callback = false;\n    return;\n  }\n\n  var shouldCall = true;\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit) shouldCall = false;\n  if (shouldCall) this.callback(false, cursor.key, cursor.value);\n  if (cursor) cursor['continue']();\n};\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument');\n  if (this._keyRangeError) return callback();\n\n  if (!this._started) {\n    this.createIterator();\n    this._started = true;\n  }\n\n  this.callback = callback;\n};","map":{"version":3,"sources":["C:/Users/jdk17/Desktop/KingFisher/kingfisher-kayaking/node_modules/level-js/iterator.js"],"names":["util","require","AbstractIterator","ltgt","module","exports","Iterator","db","options","call","_order","reverse","_limit","limit","_count","_done","lower","lowerBound","upper","upperBound","_keyRange","makeKeyRange","excludeLower","lowerBoundExclusive","excludeUpper","upperBoundExclusive","e","_keyRangeError","callback","inherits","prototype","createIterator","self","iterator","iterate","onItem","apply","arguments","keyRange","autoContinue","order","onError","err","console","log","value","cursor","cursorTransaction","shouldCall","key","_next","Error","_started"],"mappings":"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","sourcesContent":["var util = require('util')\nvar AbstractIterator  = require('abstract-leveldown').AbstractIterator\nvar ltgt = require('ltgt')\n\nmodule.exports = Iterator\n\nfunction Iterator (db, options) {\n  if (!options) options = {}\n  this.options = options\n  AbstractIterator.call(this, db)\n  this._order = options.reverse ? 'DESC': 'ASC'\n  this._limit = options.limit\n  this._count = 0\n  this._done  = false\n  var lower = ltgt.lowerBound(options)\n  var upper = ltgt.upperBound(options)\n  try {\n    this._keyRange = lower || upper ? this.db.makeKeyRange({\n      lower: lower,\n      upper: upper,\n      excludeLower: ltgt.lowerBoundExclusive(options),\n      excludeUpper: ltgt.upperBoundExclusive(options)\n    }) : null\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._keyRangeError = true\n  }\n  this.callback = null\n}\n\nutil.inherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function() {\n  var self = this\n\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments)\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function(err) { console.log('horrible error', err) },\n  })\n}\n\n// TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback()\n    this.callback = false\n    return\n  }\n  var shouldCall = true\n\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)\n    shouldCall = false\n\n  if (shouldCall) this.callback(false, cursor.key, cursor.value)\n  if (cursor) cursor['continue']()\n}\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument')\n  if (this._keyRangeError) return callback()\n  if (!this._started) {\n    this.createIterator()\n    this._started = true\n  }\n  this.callback = callback\n}\n"]},"metadata":{},"sourceType":"script"}