{"ast":null,"code":"'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n} // shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\n\n\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\nif (typeof module === 'object') module.exports = clone;\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular == 'undefined') circular = true;\n  if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren\n\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth == 0) return parent;\n    var child;\n    var proto;\n\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      } else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\n\n\nclone.clonePrototype = function (parent) {\n  if (parent === null) return null;\n\n  var c = function () {};\n\n  c.prototype = parent;\n  return new c();\n};","map":{"version":3,"sources":["C:/Users/jdk17/Desktop/KingFisher/kingfisher-kayaking/node_modules/clone/clone.js"],"names":["objectToString","o","Object","prototype","toString","call","util","isArray","ar","Array","isDate","d","isRegExp","re","getRegExpFlags","flags","global","ignoreCase","multiline","module","exports","clone","parent","circular","depth","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","RegExp","source","lastIndex","Date","getTime","isBuffer","length","copy","getPrototypeOf","create","index","indexOf","push","i","attrs","getOwnPropertyDescriptor","set","clonePrototype","c"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\n\n\nif (typeof module === 'object')\n  module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n      \n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n"]},"metadata":{},"sourceType":"script"}